#+Title: Golang
#+Date: <2018-09-15 Sat>
#+Author: Yogesh Agrawal
#+Email: yogeshiiith@gmail.com

* Introduction
  Here we will be learning golang.

* Setup
** Installation
   1. Downlod the package file from https://golang.org/dl/, open it
      and follow the prompts to install the Go tools. The package
      installs the Go distribution to =/usr/local/go=. And the package
      should put the =/usr/local/go/bin= directory in your =PATH=
      environment variable. You may need to restart any open terminal
      sessions for the change to take effect.

** Test installation
   - Create $HOME/go/src/hello directory.
   - Create a hello.go
     #+BEGIN_SRC golang
package main

import "fmt"

func main() {
	fmt.Printf("hello, world\n")
}
     #+END_SRC
   - Do =cd $HOME/go/src/hello=
   - go build
   - ./hello
     #+BEGIN_EXAMPLE
     hello, world
     #+END_EXAMPLE

** Uinstalling
   To remove an existing Go installation from your system delete the
   go directory. This is usually =/usr/local/go=. Also remove the
   =/etc/paths.d/go= file.

* Tour of Go
** Packages
   Every go program is made up of packages. Programs start running in
   package =main=. Following program is using the packages with
   imports paths "fmt" and "math/rand".
   #+BEGIN_SRC golang
   package main

   import (
      "fmt"
      "math/rand"
   )

   func main() {
       fmt.Println("My favorite number is", rand.Intn(10))
   }
   #+END_SRC

   By convention, the package name is the same as the last element of
   the import path. For instance, the =math/rand= package comprises
   files that begin with the statement =package rand=.

** imports
   Following code groups the imports into a parenthesized, "factored"
   import statement.
   #+BEGIN_SRC golang
   package main

   import (
       "fmt"
       "math"
   )

   func main(){
       fmt.Printf("Now you have %g problems.\n", math.Sqrt(7))
   }
   #+END_SRC
   It is good style to use the factored import statement instead of
   using multiple import statements.
   #+BEGIN_SRC golang
   import "fmt"
   import "math"
   #+END_SRC

** Exported Names
   In Go, a name is exported if it begins with a capital letter. For
   example, =Pizza= is an exported name, as is =Pi=, which is exported
   from the =math= package.

   When importing a package, you can refer only to its exported
   names. Any "unexported" names are not accessible from outside the
   package.

** Functions
   A function can take zero or more arguments. In the following
   example, add takes two parameters of type =int=.
   #+BEGIN_SRC golang
   package main

   import "fmt"

   func add(x int, y int) int {
       return x+y
   }

   func main(){
       fmt.Println(add(42, 13))
   }
   #+END_SRC
   Notice that the type comes after the variable name.

*** Multiple results
    A function can return any number of results. The =swap= function
    in the following example returns two strings.
    #+BEGIN_SRC golang
package main

import "fmt"

func swap(x , y string) (string, string) {
  return y, x
}

func main() {
  a, b := swap("hello", "world")
  fmt.Println(a, b)
}
    #+END_SRC

*** Named return values
    Go's return values may be named. If so, they are treated as
    variables defined at the top of the function. 

    These names should be used to document the meaning of the return
    values.

    A =return= statement without arguments returns the named return
    values. This is known as "naked" return.

    Naked returns should be used only in short functions, as with the
    following example. They can harm readability in longer functions.
    #+BEGIN_SRC golang
package main

import "fmt"

func split(sum int) (x, y int) {
  x = sum * 4 / 9
  y = sum - x
  return
}

func main() {
  fmt.Println(split(17))
}
    #+END_SRC

** Variables
   The =var= statement declares a list of variables; as in function
   arguments list, the type is last.

   A =var= statement can be at package or function level. We see both
   in the following example.
   #+BEGIN_SRC golang
package main

import "fmt"

var c, python, java bool;

func main() {
  var i int;
  fmt.Println(i, c, python, java)
}

   #+END_SRC

*** Variables with initializers
    A var declaration can include initializers, one per variable.

    If an initializer is present, the type can be omitted; the
    variable will take the type of the initializer.
    #+BEGIN_SRC golang
package main

import "fmt"

var c, python, java bool;
var d int = 2;
var e, f = 3, 4

func main() {
  var i int;
  fmt.Println(i, d, e, f, c, python, java)
}
    #+END_SRC

*** Short variable declarations
    Inside a function, the =:== short assignment statement can be used
    in place of a =var= declaration with implicit type.

    Outside a function, every statement begins with a keyword (=var=,
    =func=, and so on) and so the =:== construct is not available.
    #+BEGIN_SRC golang
package main

import "fmt"

func main() {
  var i, j int = 1, 2
  k := 3
  c, python, java := true, false, "no!"

  fmt.Println(i, j, k, c, python, java)
}
    #+END_SRC

** Types
   Go's basic types are
   #+BEGIN_EXAMPLE
   bool
   string
   int int8 int16 int32 int64
   byte // alias for uint8
   rune // alias for int32
       // represents a Unicode code point
   float32 float64
   complex64 complex128
   #+END_EXAMPLE

   Following example shows variables of several types, and also that
   variable declarations may be "factored" into blocks, as with import
   statements.
   #+BEGIN_SRC golang
package main

import (
  "fmt"
  "math/cmplx"
  )

var (
  ToBe bool = false
  MaxInt uint64 = 1<<64 - 1
  z complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
  fmt.Printf("Type: %T Value: %v\n", ToBe, ToBe)
  fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt)
  fmt.Printf("Type: %T Value: %v\n", z, z)
}  
   #+END_SRC

   The =int, uint, uintptr= types are usually 32 bits wide on 32-bit
   systems and 64 bits wide on 64-bit systems. When you need an
   integer value you should use =int= unless you have a specific
   reason to use a signed or unsigned integer type.

*** Zero values
    Variables declared without an explicit initial value are given
    their zero value.

    The zero value is:
    #+BEGIN_EXAMPLE
    0 for numeric types
    false for the boolean type, and
    "" (the empty string) for strings.
    #+END_EXAMPLE
    Example:
    #+BEGIN_SRC golang
package main

import "fmt"

func main() {
  var i int
  var f float64
  var b bool
  var s string
  fmt.Printf("%v %v %v %q\n", i, f, b, s)
}  
    #+END_SRC

*** Type conversions
    The expression =T(v)= converts the value =v= to the type =T=.
   
    Some numeric conversions:
    #+BEGIN_SRC golang
    var i int = 42
    var f float64 = float64(i)
    var u uint = uint(f)
    #+END_SRC

    Or, put simply
    #+BEGIN_SRC golang
    i := 42
    f := float64(i)
    u := uint(f)
    #+END_SRC
   
    Example:
    #+BEGIN_SRC golang
package main

import (
  "fmt"
  "math"
  )

func main() {
  var x, y int = 3, 4
  var f float64 = math.Sqrt(float64(x * x + y * y))
  var z uint = uint(f)
  fmt.Println(x, y, z)
}
    #+END_SRC

    Unlike in C, in Go assignment between items of different types
    requires an explicit conversion. Try removing the =float64= or
    =uint= conversions in the example and see what happens.

*** Type inference
    When declaring a variable without specifying an explicit type
    (either by using the =:= syntax or =var == expression syntax), the
    variable's type is inferred from the value on the right hand side.

    When the right hand side of the declaration is typed, the new
    variable is of that same type:
    #+BEGIN_SRC golang
    var i int
    j := i // j is an int
    #+END_SRC

    But when the right hand side contains an untyped numeric constant,
    the new variable may be an int, float64, or complex128 depending
    on the precision of the constant:
    #+BEGIN_SRC golang
    i := 42  // int
    f := 3.142 // float
    g := 0.867 + 0.5i // complex128
    #+END_SRC

    Example:
    #+BEGIN_SRC golang
package main

import "fmt"

func main() {
  v := 42.3
  fmt.Printf("v is of type %T\n", v)
}
    #+END_SRC
    
    Try changing the initial value of =v= in the example code and
    observe how its type is affected.

* Reference
  1. Golang installation: https://golang.org/doc/install
  2. Golang Tour https://tour.golang.org/welcome/1
  3. How to write go code: https://golang.org/doc/code.html
  4. Golang repository: https://github.com/golang/go
