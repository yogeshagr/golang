#+Title: Golang
#+Date: <2018-09-15 Sat>
#+Author: Yogesh Agrawal
#+Email: yogeshiiith@gmail.com

* Introduction
  Here we will be learning golang.

* Setup
** Installation
   1. Downlod the package file from https://golang.org/dl/, open it
      and follow the prompts to install the Go tools. The package
      installs the Go distribution to =/usr/local/go=. And the package
      should put the =/usr/local/go/bin= directory in your =PATH=
      environment variable. You may need to restart any open terminal
      sessions for the change to take effect.

** Test installation
   - Create $HOME/go/src/hello directory.
   - Create a hello.go
     #+BEGIN_SRC golang
package main

import "fmt"

func main() {
	fmt.Printf("hello, world\n")
}
     #+END_SRC
   - Do =cd $HOME/go/src/hello=
   - go build
   - ./hello
     #+BEGIN_EXAMPLE
     hello, world
     #+END_EXAMPLE

** Uinstalling
   To remove an existing Go installation from your system delete the
   go directory. This is usually =/usr/local/go=. Also remove the
   =/etc/paths.d/go= file.

* Tour of Go
** Basics
*** Packages, variables and functions
    Learn the basic components of any Go program.
**** Packages
     Every go program is made up of packages. Programs start running
     in package =main=. Following program is using the packages with
     imports paths "fmt" and "math/rand".
     #+BEGIN_SRC golang
     package main

     import (
       	"fmt"
       	"math/rand"
     )

     func main() {
       	 fmt.Println("My favorite number is", rand.Intn(10))
     }
     #+END_SRC

     By convention, the package name is the same as the last element
     of the import path. For instance, the =math/rand= package
     comprises files that begin with the statement =package rand=.

**** imports
     Following code groups the imports into a parenthesized,
     "factored" import statement.
     #+BEGIN_SRC golang
     package main

     import (
       	 "fmt"
       	 "math"
     )

     func main(){
       	 fmt.Printf("Now you have %g problems.\n", math.Sqrt(7))
     }
     #+END_SRC

     It is good style to use the factored import statement instead of
     using multiple import statements.
     #+BEGIN_SRC golang
     import "fmt"
     import "math"
     #+END_SRC

**** Exported Names
     In Go, a name is exported if it begins with a capital letter. For
     example, =Pizza= is an exported name, as is =Pi=, which is
     exported from the =math= package.

     When importing a package, you can refer only to its exported
     names. Any "unexported" names are not accessible from outside the
     package.

**** Functions
     A function can take zero or more arguments. In the following
     example, add takes two parameters of type =int=.
     #+BEGIN_SRC golang
     package main

     import "fmt"

     func add(x int, y int) int {
       	 return x+y
     }

     func main(){
       	 fmt.Println(add(42, 13))
     }
     #+END_SRC
     Notice that the type comes after the variable name.

***** Multiple results
      A function can return any number of results. The =swap= function
      in the following example returns two strings.
      #+BEGIN_SRC golang
package main

import "fmt"

func swap(x , y string) (string, string) {
  return y, x
}

func main() {
  a, b := swap("hello", "world")
  fmt.Println(a, b)
}
      #+END_SRC

***** Named return values
      Go's return values may be named. If so, they are treated as
      variables defined at the top of the function.

      These names should be used to document the meaning of the return
      values.

      A =return= statement without arguments returns the named return
      values. This is known as "naked" return.

      Naked returns should be used only in short functions, as with
      the following example. They can harm readability in longer
      functions.
    #+BEGIN_SRC golang
package main

import "fmt"

func split(sum int) (x, y int) {
  x = sum * 4 / 9
  y = sum - x
  return
}

func main() {
  fmt.Println(split(17))
}
    #+END_SRC

**** Variables
     The =var= statement declares a list of variables; as in function
     arguments list, the type is last.

     A =var= statement can be at package or function level. We see
     both in the following example.
     #+BEGIN_SRC golang
package main

import "fmt"

var c, python, java bool;

func main() {
  var i int;
  fmt.Println(i, c, python, java)
}

     #+END_SRC

***** Variables with initializers
      A var declaration can include initializers, one per variable.

      If an initializer is present, the type can be omitted; the
      variable will take the type of the initializer.
      #+BEGIN_SRC golang
package main

import "fmt"

var c, python, java bool;
var d int = 2;
var e, f = 3, 4

func main() {
  var i int;
  fmt.Println(i, d, e, f, c, python, java)
}
      #+END_SRC

***** Short variable declarations
      Inside a function, the =:== short assignment statement can be
      used in place of a =var= declaration with implicit type.

      Outside a function, every statement begins with a keyword
      (=var=, =func=, and so on) and so the =:== construct is not
      available.
      #+BEGIN_SRC golang
package main

import "fmt"

func main() {
  var i, j int = 1, 2
  k := 3
  c, python, java := true, false, "no!"

  fmt.Println(i, j, k, c, python, java)
}
      #+END_SRC

**** Types
     Go's basic types are
     #+BEGIN_EXAMPLE
     bool
     string
     int int8 int16 int32 int64
     byte // alias for uint8
     rune // alias for int32
         // represents a Unicode code point
     float32 float64
     complex64 complex128
     #+END_EXAMPLE

     Following example shows variables of several types, and also that
     variable declarations may be "factored" into blocks, as with
     import statements.
     #+BEGIN_SRC golang
package main

import (
  "fmt"
  "math/cmplx"
  )

var (
  ToBe bool = false
  MaxInt uint64 = 1<<64 - 1
  z complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
  fmt.Printf("Type: %T Value: %v\n", ToBe, ToBe)
  fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt)
  fmt.Printf("Type: %T Value: %v\n", z, z)
}  
   #+END_SRC

     The =int, uint, uintptr= types are usually 32 bits wide on 32-bit
     systems and 64 bits wide on 64-bit systems. When you need an
     integer value you should use =int= unless you have a specific
     reason to use a signed or unsigned integer type.

***** Zero values
      Variables declared without an explicit initial value are given
      their zero value.

      The zero value is:
      #+BEGIN_EXAMPLE
      0 for numeric types
      false for the boolean type, and
      "" (the empty string) for strings.
      #+END_EXAMPLE
      Example:
      #+BEGIN_SRC golang
package main

import "fmt"

func main() {
  var i int
  var f float64
  var b bool
  var s string
  fmt.Printf("%v %v %v %q\n", i, f, b, s)
}  
      #+END_SRC

***** Type conversions
      The expression =T(v)= converts the value =v= to the type =T=.
   
      Some numeric conversions:
      #+BEGIN_SRC golang
      var i int = 42
      var f float64 = float64(i)
      var u uint = uint(f)
      #+END_SRC

      Or, put simply
      #+BEGIN_SRC golang
    i := 42
    f := float64(i)
    u := uint(f)
    #+END_SRC
   
      Example:
      #+BEGIN_SRC golang
package main

import (
  "fmt"
  "math"
  )

func main() {
  var x, y int = 3, 4
  var f float64 = math.Sqrt(float64(x * x + y * y))
  var z uint = uint(f)
  fmt.Println(x, y, z)
}
    #+END_SRC

      Unlike in C, in Go assignment between items of different types
      requires an explicit conversion. Try removing the =float64= or
      =uint= conversions in the example and see what happens.

***** Type inference
      When declaring a variable without specifying an explicit type
      (either by using the =:= syntax or =var == expression syntax),
      the variable's type is inferred from the value on the right hand
      side.

      When the right hand side of the declaration is typed, the new
      variable is of that same type:
      #+BEGIN_SRC golang
      var i int
      j := i // j is an int
      #+END_SRC

      But when the right hand side contains an untyped numeric
      constant, the new variable may be an int, float64, or complex128
      depending on the precision of the constant:
      #+BEGIN_SRC golang
      i := 42  // int
      f := 3.142 // float
      g := 0.867 + 0.5i // complex128
      #+END_SRC

      Example:
      #+BEGIN_SRC golang
package main

import "fmt"

func main() {
  v := 42.3
  fmt.Printf("v is of type %T\n", v)
}
      #+END_SRC
    
      Try changing the initial value of =v= in the example code and
      observe how its type is affected.

***** Constants
      Constants are declared like variables, but with the =const= keyword.

      Constants can be character, string, boolean, or numeric values.
 
      Constants cannot be declared using the =:== syntax.

      Example:
      #+BEGIN_SRC golang
package main

import "fmt"

const Pi = 3.14

func main() {
  const World = "world"
  fmt.Println("Hello", World)
  fmt.Println("Happy", Pi, "day")

  const Truth = true
  fmt.Println("Go rules?", Truth)

}
      #+END_SRC

*** Flow control statements: for, if, else, switch and defer
    Learn how to control the flow of your code with conditionals,
    loops, switches and defers.
**** For
     Go has only one looping structure, the =for= loop.

     The basic for loop has three components separated by semicolons:
    
     #+BEGIN_EXAMPLE
     the init statement: executed before the first iteration
     the condition statement: evaluated before every iteration
     the post statement: executed at the end of every iteration
     #+END_EXAMPLE

     The variables declared in the for loop are visible only in the
     scope of the =for= statement.
     #+BEGIN_SRC golang
package main

import "fmt"

func main() {
  sum := 0
  for i := 0; i < 10; i++ {
    sum += i
  }

  fmt.Println(sum)

  for sum < 100 {
    sum += sum
  }

  fmt.Println(sum)

// infinite loop
  for {

  }

}   
    #+END_SRC
 
     There are no parentheses surrounding the three components of the
     =for= statement and the braces ={ }= are always required.

**** If
     Go's =if= statement are like =for= loops; the expression need not
     be surrounded by parentheses =()= but the braces ={}= are
     required.

     Like =for=, the =if= statement can start with a short statement
     to execute before the condition.

     Variables declared by the statement are only in scope until the
     end of the =if=.
     #+BEGIN_SRC golang
package main

import (
  "fmt"
  "math"
)

func pow(x, n, lim float64) float64 {
  if v := math.Pow(x, n); v < lim {
    return v
  }
  return lim
}

func main() {
  fmt.Println(
    pow(3, 2, 10),
    pow(3, 3, 20),
  )
}    
     #+END_SRC

     Try using =v= in the last =return= statement.
     #+BEGIN_EXAMPLE
     # command-line-arguments
     src/hello/if.go:12:10: undefined: v
     #+END_EXAMPLE

**** If and else
     Variables declared inside an =if= short statement are also
     available inside any of the =else= blocks.

**** Switch
     A =switch= statement is a shorter way to write a sequence of
     =if - else= statements. It runs the first case whose value is
     equal to the condition expression.

     #+BEGIN_SRC golang
package main

import (
  "fmt"
  "runtime"
)

func main() {
  fmt.Println("Go runs on")
  switch os := runtime.GOOS; os {
  case "darwin":
    fmt.Println("OS X.")
  case "linux":
    fmt.Println("Linux.")
  default:
    fmt.Printf("%s.", os)
  }
}
     #+END_SRC

**** Defer
     A defer statement defers the execution of a function until the
     surrounding funtion returns.

     The defered call's arguments are evaluated immediately, but the
     function call is not executed until the surrounding function
     returns.

     #+BEGIN_SRC golang
package main

import "fmt"

func main() {
  defer fmt.Println("world")

  fmt.Println("hello")
}     
     #+END_SRC

*** More types: structs, slices, and maps
    Learn how to define types based on the existing ones: this lesson
    covers structs, arrays, slices and maps.
**** Pointers
     A points holds the memory address of a value.

     The type =*T= is a pointer to a =T= value. Its zero value is
     =nil=.

     =var p *int=

     The =&= operator generates a pointer to its operand.
     #+BEGIN_SRC golang
     i := 42
     p = &i
     #+END_SRC
     
     The =*= operator denotes the pointer's underlying value.
     #+BEGIN_SRC golang
     fmt.Println(*p)
     *p = 21
     #+END_SRC

     #+BEGIN_SRC golang
package main

import "fmt"

func main() {
  i, j := 42, 2701

  p := &i
  fmt.Println(*p)

  *p = 21
  fmt.Println(i)

  p = &j
  *p = *p / 37
  fmt.Println(j)

  fmt.Println(p)

}     
     #+END_SRC

**** Structs
     A =struct= is a collection of fields.

     In the following example we are defining a type Vertex which is
     of type struct.
     #+BEGIN_SRC golang
package main

import "fmt"

type Vertex struct {
  X int
  Y int
}

func main() {
  fmt.Println(Vertex{2, 3})
  fmt.Println(2)
}
     #+END_SRC

**** Pointers to structs
     Struct fields can be accessed through a struct pointer.

     To access the field =X= of a struct when we have the struct
     pointer =p= we could write =(*p).X=. However, that notation is
     cumbersome, so the language permits us instead to write just
     =p.X=, without the explicit dereference.
     #+BEGIN_SRC golang
package main

import "fmt"

type Vertex struct {
  X int
  Y int
}

func main() {
  fmt.Println(Vertex{2, 3})
  fmt.Println(2)

  v := Vertex{1, 2}
  v.X = 4
  fmt.Println(v.X)

  p := &v
  p.X = 1e9
  fmt.Println(v)

}
     #+END_SRC
     
     #+BEGIN_SRC golang
package main

import "fmt"

type Vertex struct {
  X, Y int
}

var (
  v1 = Vertex{1, 2}
  v2 = Vertex{X: 1}
  v3 = Vertex{}
  p1 = &Vertex{1, 2}
  p2 = &v1
)

func main() {
  fmt.Println(v1, v2, v3, p1, &p2, *p1)
}
     #+END_SRC
     
**** Arrays
     The type =[n]T= is an array of =n= values of type =T=.

     The expression
     #+BEGIN_SRC golang
var a [10]int
     #+END_SRC
     declares a variable =a= as an array of ten integers.

     An array's length is part of its type, so arrays cannot be
     resized.
     #+BEGIN_SRC golang
package main

import "fmt"

func main() {
  var a [2]string
  a[0] = "Hello"
  a[1] = "World"

  fmt.Println(a[0], a[1])
  fmt.Println(a)

  primes := [6]int{2, 3, 5, 7, 11, 13}
  fmt.Println(primes)

}
     #+END_SRC

**** Slices
     An array has a fixed size. A slice, on the other hand, is a
     dynamically-sized, flexible view into the elements of an
     array. In practise, slices are much more common than arrays.

     The type =[]T= is a slice with elements of type =T=.

     A slice is formed by specifying two indices, a low and high
     bound, separated by a colon.
     #+BEGIN_EXAMPLE
     a[low : high]
     #+END_EXAMPLE

     This selects a half-open range which includes the first element,
     but excludes the last one.
     #+BEGIN_SRC golang
package main

import "fmt"

func main() {
  primes := [6]int{2, 3, 5, 7, 11, 13}

  var s []int = primes[1:4]
  fmt.Println(s)
}
     #+END_SRC

***** Pointers to slices
      Slices are like reference to arrays. A slice does not store any
      data, it just describes a section of an underlying array.

      Changing the elements of a slice modifies the corresponding
      elements of its underlying array.

      Other slices that share the same underlying array will see those
      changes.

      #+BEGIN_SRC golang
package main

import "fmt"

func main() {
  names := [4]string{
    "John",
    "Paul",
    "George",
    "Ringo",
  }
  fmt.Println(names)

  a := names[0:2]
  b := names[1:3]
  fmt.Println(a, b)

  b[0] = "XXX"
  fmt.Println(a, b)
  fmt.Println(names)

}
     #+END_SRC

***** Slice literals
      #+BEGIN_SRC golang
package main

import "fmt"

func main() {
  q := []int{2, 3, 5, 7, 11, 13}
  fmt.Println(q)

  r := []bool{true, false, true, true, false, true}
  fmt.Println(r)

  s := []struct{
    i int
    b bool
  }{
    {2, true},
    {3, false},
    {5, true},
    {7, true},
    {11, false},
    {13, true},
  }
  fmt.Println(s)
}
      #+END_SRC

***** Slice length and capacity
      The lenght of a slice is the number of elements it contains.

      The capacity of a slice is the number of elements in the
      underlying array, counting from the first element in the slice.

      The lenght and capacity of a slice =s= can be obtained using the
      expressions =len(s)= and =cap(s)=.

      #+BEGIN_SRC golang
package main

import "fmt"

func main() {
  s := []int{2, 3, 5, 7, 11, 13}
  printSlice(s)

  // Slice the slice to give it zero length
  s = s[:0]
  printSlice(s)

  // Extend its length
  s = s[:4]
  printSlice(s)

  // Drop its first two element
  s = s[2:]
  printSlice(s)

}

func printSlice(s []int){
  fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
      #+END_SRC

* Reference
  1. Golang installation: https://golang.org/doc/install
  2. Golang Tour https://tour.golang.org/welcome/1
  3. How to write go code: https://golang.org/doc/code.html
  4. Golang repository: https://github.com/golang/go
